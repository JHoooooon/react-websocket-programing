# 리엑트 소켓 프로그래밍

> 책 `리액트로 배우는 소켓 프로그래밍` 을 보면 `socket` 관련 내용을 정리한다.

첫장에서는 `react` 에 대한 소개가 이루어진다.
`react` 자체가 오직 `view` 만을 생각해서 만들었으며, `DOM` 을 동적으로  
자연스럽게 변경하는 것을 연구했다고 한다.

이를 `Virtual DOM` 을 사용하여 해결했다

## Virtual DOM

가상 `DOM` 을 사용하기 위해서는 `DOM` 이 무엇인지 알아야 한다

### DOM

`DOM`(`Document Object Model`) 을 말하며 웹 페이지의 구조와 내용을 표현하는  
역할을 한다.

`HTML`, `CSS` 와 같은 정적 브라우저에 렌더링을 시작하면 `HTML` 코드를 브라우저가  
이해할수 있는 구조로 변환하여 `DOM` 트리를 생성한다

`DOM` 은 마치 부모 자식 형식으로 이루어져 있어 `Tree` 구조라고 한다.

`HTML` 문서를 파싱하여 `DOM` 트리를 생성하면 `CSS` 를 파싱한다.
이렇게 `CSS` 를 파싱하여 객체화시킨것을 `CSSOM(CSS Object Modle)` 이라 부른다.

이후 `DOM` 과 `CSSOM` 을 결합하여 `RenderTree` 를 생성한다.
생성된 `RenderTree` 는 화면에 실제로 표시되는 요소들을 포함한다

브라우저는 이러한 `RenderTree` 를 이용하여 화면에 표시될 영역을 계산하는  
레이아웃(`Reflow`) 과정과 `Node` 를 화면에 픽셀로 변환하는 `Repaint` 과정을  
거쳐 변환된 내용이 화면에 표시된다.

이러한 과정을 보면 이후 `Rendering` 된 웹 서비스에서 동작이 일어날때,  
동작이 어떻게 일어나며, 이에 따른 성능에 대해서 고민해볼 수 있다.

책에서는 햄버거 버튼을 누르면 위에서 아래로 사이드 메뉴가 등장하는 예시를 말한다

햄버거 메뉴를 누르면 아래에서 위로 메뉴리스트가 등장하며, `css` 의 `height` 을  
조작한다.

이러한 과정을 `Reflow` 라 한다.

`Reflow` 는 `DOM` 의 변화로 일어나며, 보통은 굉장히 빠르게 진행된다
이는 자원소모가 그렇게 많지 않을수 있다

그렇지만, `DOM` 트리가 깊어지고, 노드의 수가 많아지면 속도가 떨어질수 있다.

### 비교 알고리즘

`DOM` 을 변경하면 변화환 노드를 찾는데 시간이 걸린다
이는 `Root Node` 에서 부터 하나씩 탐색하여, 원하는 `Node` 에 다다르게 되고,  
원하는 수치로 변경한다.

이때 비교 알고리즘(`diffing algorithm`) 이라는 탐색방법을 사용한다
이는 노드의 개수가 많고 깊이가 깊을수록 오래 걸린다

> 탐색해야할 노드를 찾는데 탐색을 더 많이 해야 하기 때문이다

그렇기에 변화하는 리페인트, 리플로우 과정을 줄인다면 사용자에게 더 자연스러운  
화면과 성능을 제공할 수 있다

> 인터렉션이 많은 페이지라면 많은 변화로 인해 느려질수도 있다.
하지만 `DOM` 은 충분히 빠르고 사용가능하다

### 가상 DOM 의 탄생

`Virtual DOM` 은 이러한 `Reflow`, `Repaint` 과정을 개선하기 위한 방법이다.
이는 기존의 `DOM` 과 같은 `메모리상의 DOM` 을 비교한다

> `메모리상의 DOM` 이 `Virtual DOM` 이다

`react` 는 `root node` 부터 시작해서 탐색하지 않는다.
`react` 는 변경된 `node` 만 검색해서 변경 사항을 변경한다

변경사항을 바로 실제 `DOM` 에 변경하지 않고, 변경이 전부 완료되었다면, 그때
실제 `DOM` 에 반영한다

> 이는 `DOM` 에 매번 변경이 일어날때마다 반영되지 않고 딱 한번만 반영한다

이러한 과정을 조화(`reconciliation`) 과정이라고 한다

가상 `DOM` 을 사용하는 이유는 렌더트리를 직접 조작하는것보다 `Virtural DOM` 을  
수정하여 필요한 변경 사항만 파악하고 반영하는것이 효율적이기 때문이다.

> 가상 `DOM` 은 메모리상에 존재하기에 실제 `DOM` 에 반영하는 것 보다 더
빠르게 파악하고 적용할수 있다.

## NodeJS

`nodejs` 는 `javascript runtime` 환경을 말한다

### 멀티 스레드 기반 동기 방식

`nodejs` 는 빠른 네트워크 처리를 특징으로 한다
이는 기존 웹 서버와 다른 방식을 처리하는 `nodejs` 의 특징때문으로,
다른 웹 서버들은 요청을 처리할때 동기 방식으로 일을 처리한다

이말은 처리되는 일이 있다면, 이 일이 완료되어야만 다음일을 처리할 수 있다.
이는 `input/output` 에 의한 `buttleneck` 현상이 발생하는데, 이를 `blocking`  
되었다고 한다.

> 서버의 부하의 원인은 대부분 이러한 `I/O` 에서 발생한다.

이러한 `I/O` 블로킹을 해결하기 위한 방법으로 `thread` 를 지원하기 시작한다.
여러 `thread` 를 사용하여 서버의 요청 처리를 나누어서 처리하는데, 이때 여러개의  
`thread` 를 사용한다고 하여 `multi thread` 라 한다.

각 `thread` 는 동시에 여러 요청을 받을 수 있도록 한다.

> `thread` 는 `CPU` 자원을 나눠서 갖는 형태를 가진다.
> 그렇기에 `CPU Resource` 가 고갈되면 요청을 처리하지 못하는 상황이 발생하기도 한다.
> 또한 공통된 `resource`를 어떻게 공유할것이지도 문제가 된다.

### Event 기반 비동기 방식

`thread` 의 한계를 극복하기 위해서 비동기 방식이 등장한다.
비동기는 `single thread` 인 `javascript` 의 특징중 하나이다.

비동기는 함수를 `background` 에 넘겨 실행시키고, 해당 콜백함수를  
`event queue` 에 넣어 준다.

이후, `callstack` 이 비워지면(`동기적으로 작동하는 code 들`), 그때, `event loop` 가  
감지하여, `event queue` 에 저장된 `callback` 함수를 하나씩 실행시켜 `callstack` 에  
담아 처리한다.

> 실상, `single thread` 라고 했지만, 처리하는 방식을 보면 다른 `thread` 를 사용하여  
처리하는것을 볼 수 있다.

`event` 기반은 `javascript` 에서 사용하는 이벤트와 콜백함수를 통해 작업을  
처리해주는 방식이다

이는 해당 `event` 가 발생하면 해당 이벤트를 감지하고 이벤트가 발생했음을  
알려주는 콜백함수가 실행된다.

이는 기존의 `multi thread` 방식보다 `자원 효율성` 측면에서 오버헤드가 덜하다.
또한 코드가 단순해지며(`multi thread` 사용시 다중 처리를 위해 코드가 복잡해진다.)  
`thread` 로 처리 하지 않으므로, `thread` 수에 영향을 받지 않는다. 즉,  
여러 수신 요청을 동시 연결 또는 처리하는데 적합하다

## Socket 통신

웹은 `HTTP` 통신만으로도 충분히 멋진 기능을 만들어낸다
하지만, 더 효율적인 웹 서비스를 위해서라면 소켓 통신은 필수이다.

실시간 으로 변경되는 정보를 다루는 어플리케이션이라면 소켓 통신을 사용해야 한다.

이를 이해하기 위해서는 `OSI 7 layer` 를 보도록 하자

### OSI 7 Layer 구조

보통 네트워크의 개념을 이해할때, 이 구조를 사용하여 설명을 한다.

> `1980` 년대 인터넷이 보급되면서 네트워크 통신을 하는 회사들이 생겨나기 시작  
한다. 하지만, 인터넷 네트워크 통신을 담당하는 제조사들이 서로 다른 방식으로  
통신하기 시작하면서, 이러한 문제를 없애기 위해 `ISO(국제 표준 기구)` 가  
통신규약에대한 통신구조를 만들어낸것이 `OSI`(`Open Systems Interconnection`) 이다.

```sh
+-------------------------+                              
|        Application      | --- 응용계층 7 layer
+-------------------------+
|        Presentation     | --- 표현계층 6 layer
+-------------------------+
|           Session       | --- 세션계층 5 layer
+-------------------------+
|         Transport       | --- 전송계층 4 layer
+-------------------------+
|          Network        | --- 네트워크 계층 3 layer
+-------------------------+
|           Data Link     | --- 데이터 링크 계층 2 layer
+-------------------------+
|          Physical       | --- 물리 계층 1 layer
+-------------------------+
```

1. **물리계층**:
전기적, 기계적 틍성을 이용하여 데이터를 전송한다.
데이터는 `0` 과 `1` 뿐이며 데이터 전달하는 기능만 있기 때문에
오류제어와 알고리즘 같은 역할 수행은 어렵다
2. **데이터 링크 계층**:
물리적 연결을 담당하며 `MAC` 주소를 이용하여 통신한다
3. **네트워크 계층**:
라우팅의 역할을 밭고 있다. 가장 빠르고 안전한 경로를 안내한다.
4. **전송 계층**:
장치 사이의 신뢰성 있는 데이터 전송, 오류 검출, 데이터 흐름 제어를 담당한다.
5. **세션 계층**:
두 장치 사이의 동기화를 담당한다. 오류가 발생하면 복하는 과정이 이루어진다.
6. **프레젠테이션 계층**:
데이터를 표현하는 계층으로 데이터 암호화, 복호화, 압축 등을 담당한다
7. **응용 계층**:
사용자 또는 애플리케이션에 직접 네트워크 서비스를 제공

각 역할과 프로토콜의 영역이 다르다

***중요한 점은 송신하는 입장에서는 각 단계를 거치면서 헤더 정보를 추가해서  
수신자에게 보낸다는 사실이다.***

이 데이터 덩어리(`Chunks`)를 받은 수신자는 반대로 헤더의 정보를 해석하면서 정보를 받게 된다.

### TCP/IP 4 계층

`OSI` 는 7계층으로 되어있다. 하지만, 데이터를 어떻게 하면 원하는 위치에  
안정적으로 전송할수 있는 방법을 고민하게 되었다고 책에서 설명한다.

이 과정에서 7계층 보다는, 더 단순화된 모델인 `TCP/IP` 4계층이 나오게 되었다고 한다.

`TCP`(`Transmission Control Protocol`) 는 전송제어 프로토콜로써 포트 번호를  
사용하며 기기 간의 `안전한` 데이터 전송을 담당한다

> 이외에 `UDP`(`User Datagram Protocal`) 로써, 안정성을 포기하고, 빠른 데이터  
전송에 초점을 맞춤 프로토콜도 존재한다

`IP`(`Internet Protocal`) 은 기기간의 빠른 데이터 전송을 위한 프로토콜이다
`IP` 주소가 이 프로토콜로 인해 생겨났다고 한다.

## Socket 통신

> 소켓 통신이란 `TCP` 와 `UDP` 프로토콜을 사용하는 두 기기간의 연결을 말한다.
> 이런 연결을 하기 위해 특정한 `IP` 주소와 포트 번호를 이용해서 통신 연결을  
유지한다.

이러한 통신 연결을 유지하기 위해 `Connection` 을 사용한다.
이는 지속적인 연결 유지를 위해 컴퓨터 자원을 소모하며, 커넥션이 많을 수록 부하가  
발생한다.

보통은 `HTTP` 통신(`단반향 통신`)을 사용하지만, 데이터 통신이 자주 일어나는  
통신(`실시간 데이터 교환`) 같은 경우 `Scoket` 통신을 사용하여 처리한다.

### 소켓 통신 프로토콜

소켓 통신이 이루어지는 과정은 다음과 같다

#### 3방향 핸드쉐이크

`3Way handshake` 는 신뢰성있는 연결을 위해 `Client` 와 `Server` 간의 사전작업  
을 말한다.

이는 다음과 같은 과정을 가진다.

```sh
Client                       Server

  [1] ----- [SYN] ---------->

      <------ [SYN, ACK] ---  [2]
                               
  [3] ------ [ACK] ---------->

```

1. **`Client` 에서 `SYN` 전송**:
클라이언트는 `SYN(동기화)` 플래그가 설정된 `TCP` 세그먼트를 서버에 전송하여  
연결을 시작한다.
2. **`Server` 가 `SYN` 및 `ACK` 응답**:
`SYN` 세그먼트를 수신하면 서버는 `SYN` 과  `ACK(승인)` 플래그와 함께  
`TCP` 세그먼트를 전송하여 응답한다.
3. **`Client` 가 `Server` 로 부터 `SYN` 를 승인**:
`ACK` 을 받은 클라이언트는 다시 `Server` 로 `ACK` 패킷을 보내며 잘 받았다는  
요청을 보낸다.

이렇게 `3-Way handshake` 가 이루어진후, 소켓 통신이 이루어진다

> 이는 `TCP` 에서 통신을 맺기 위한 과정으로, `UDP` 에서는 `3-Way handshake` 는  
하지 않는다.
>
> `UDP` 는 신뢰성있는 통신(`Client` 와 `Server` 간의 통신이 이루어질수 있는지 확인  
하는 과정) 이 필요없다.
>
> `UDP` 는 빠른 데이터 통신을 위한 목적이므로, 데이터그램이 손실되든 상관없이  
데이터를 보낸다.

## net 모듈을 이용한 TCP 서버

